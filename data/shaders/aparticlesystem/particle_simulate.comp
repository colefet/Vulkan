#version 450

//todo:common.h
struct Particle
{
	vec3 pos;
    float lifeMax;
	vec3 vel;
    float life;
	vec4 gradientUV;
};


layout (binding = 0) uniform UBOSimulate
{
	float deltaT;
	float destX;
	float destY;
	int padding0;
} uboSimulate;

//Particle storage buffer
layout(std140, binding = 1) buffer SSBOParticle 
{
    Particle particles[ ];
}ssboParticle;
layout(std140, binding = 2) buffer SSBODead
{
    uint list[ ];
}ssboDead;
layout(std140, binding = 3) buffer SSBOAlive
{
    uint list[ ];
}ssboAlive;
layout(std140, binding = 4) buffer SSBOAliveAfterSimulate
{
    uint list[ ];
}ssboAliveAfterSimulate;
layout(std140, binding = 5) buffer SSBOCounter
{
    uint emitCount;
    uint deadCount;
    uint aliveCount;
    uint aliveCountAfterSimulate;
}ssboCounter;


vec2 attraction(vec2 pos, vec2 attractPos) 
{
    vec2 delta = attractPos - pos;
	const float damp = 0.5;
    float dDampedDot = dot(delta, delta) + damp;
    float invDist = 1.0f / sqrt(dDampedDot);
    float invDistCubed = invDist*invDist*invDist;
    return delta * invDistCubed * 0.0035;
}

vec2 repulsion(vec2 pos, vec2 attractPos)
{
	vec2 delta = attractPos - pos;
	float targetDistance = sqrt(dot(delta, delta));
	return delta * (1.0 / (targetDistance * targetDistance * targetDistance)) * -0.000035;
}
 
layout (local_size_x = 256) in;
void main() 
{
    // Current SSBO index
    uint index = gl_GlobalInvocationID.x;
	// Don't try to write beyond particle count
    if (index >= ssboCounter.aliveCount) {return;}

    // simulation can be either fixed or variable timestep:
	//const float dt = xEmitterFixedTimestep >= 0 ? xEmitterFixedTimestep : g_xFrame_DeltaTime;
    const float dt = uboSimulate.deltaT;

    // Read position and velocity
    uint particleIndex = ssboAlive.list[index];
    if(ssboParticle.particles[particleIndex].life > 0){
        /*vec2 vVel = ssboParticle.particles[particleIndex].vel.xy;
        vec2 vPos = ssboParticle.particles[particleIndex].pos.xy;

        vec2 destPos = vec2(uboSimulate.destX, uboSimulate.destY);

        vec2 delta = destPos - vPos;
        float targetDistance = sqrt(dot(delta, delta));
        vVel += repulsion(vPos, destPos.xy) * 0.05;

        // Move by velocity
        vPos += vVel * uboSimulate.deltaT;

        // collide with boundary
        if ((vPos.x < -1.0) || (vPos.x > 1.0) || (vPos.y < -1.0) || (vPos.y > 1.0)){
            vVel = (-vVel * 0.1) + attraction(vPos, destPos) * 12;
        }
        else{
            ssboParticle.particles[particleIndex].pos.xy = vPos;
        }

        // Write back
        ssboParticle.particles[particleIndex].vel.xy = vVel;
        ssboParticle.particles[particleIndex].gradientUV.x += 0.02 * uboSimulate.deltaT;
        if (ssboParticle.particles[particleIndex].gradientUV.x > 1.0){
            ssboParticle.particles[particleIndex].gradientUV.x -= 1.0;
        }*/
        ssboParticle.particles[particleIndex].life -= dt;

        // add to new alive list:
        uint alive_count = atomicAdd(ssboCounter.aliveCountAfterSimulate,1);
        ssboAliveAfterSimulate.list[alive_count]=particleIndex;

    }
    else{
        // add to dead list:
        uint dead_count = atomicAdd(ssboCounter.deadCount,1);
        ssboDead.list[dead_count]=particleIndex;
    }
    
}

